+ # 相向双指针

  相向双指针主要是指两个指针面对面走，常见需要掌握的题目一般有下列：

  1. quicksort
  2. 归并排序
  3. 第k大的数字
  4. 有效回文串
  5. Two/Three Sum
  6. 判断有效三角形个数
  7. Reverse 类

  

  NOTE：基于比较的排序算法，做不到On，理论下界是Onlogn

  模版例题

  #### [611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

  ```
  class Solution:
      def triangleNumber(self, nums: List[int]) -> int:
          if not nums:
              return 0 
          nums.sort()
          ans = 0
          S = nums
          for i in range(2, len(S)):
              # for 循环中对每个i都做一次相向双指针的判断
              left, right = 0, i - 1
              while left < right:
                  if S[left] + S[right] > S[i]:
                      ans += right - left
                      right -= 1
                  else:
                      left += 1
          return ans
  ```

  #### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

  给定一个字符串，判断其是否为一个回文串。只考虑字母和数字，忽略大小写。

  ```python
  class Solution:
      def isPalindrome(self, s: str) -> bool:
          # write your code here
          if not s:
              return True 
          
          left = 0
          right = len(s) - 1
          # 相向双指针
          while left <= right:
              while left <= right and not s[left].isalnum():
                  left += 1
              while left <= right and not s[right].isalnum():
                  right -= 1
              if left <= right:
                  if s[left].lower() != s[right].lower():
                      return False 
                  left += 1 
                  right -= 1
          
          return True
  ```

  

  快速排序：

  快速排序中间的比较，不要把等于pivot包括进去，可以加快速度。但是也不能漏掉left<=right** 之所以不要等于，就是为了避免都是一堆相等的数字的情况，做了无用功。

  因为快速排序的本质是将数组分成两个部分，左边大于，右边小于，等于的无所谓在哪边。

  如果包含了等于就会有下面的情况出现。不包含就可以一轮推出了

  [1,1,1,1,1] ==> [1,1,1,1,1] []

  quicksort比归并排序要快，因为是inplace的，减少了开辟数组空间以及复制数据的时间损耗

  

  ```python
  # Quick Sort
  class Solution:
      def sortIntegers(self, A):
          if A == None or len(A) == 0:
              return
          self.quickSort(A, 0, len(A) - 1)
          
      def quickSort(self, A, left, right):
          if start >= end:
              return
          
          ### partition 让所有小于pivot的数字在左边，大于pivot的数字在右边
          l = left 
          r = right
          pivot = A[(start+end)//2] # 1. avoid the wroest situation
          
          while left <= right: # 2. <= not < 是为了避免漏掉数据
              # 3. = pivot的时候可以在做也可以在右。为了避免使重复数据存在的时候，会出现极端情况。=可以避免不均匀的划分
              while left <= right and A[left] < pivot:
                  left += 1
              while left <= right and A[right] > pivot:
                  right -= 1
                  
              if left <= right:
                  A[left], A[right] = A[right], A[left]
                  left += 1
                  right -= 1
          ### partition的结束
          # 结束的时候，left和right会错位。left > right
          self.quickSort(A, l, right) 
          self.quickSort(A, left, r)
  ```

  #### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

  ```python
  class Solution:
      def maxArea(self, height: List[int]) -> int:
          """
          ok. 这个题目嘛。做过好多次还是会忘记。总之应该先找到切入点
          首先说了n至少为2.那么就不用做非空判断.
          看一下这个图，左边和右边的比较短的那个柱子。会决定水的高。距离决定水的width。
          那么就有了结果了。遍历一下。
          """
          res = 0
          left = 0 
          right = len(height) - 1
          while left <= right:
              lmax = height[left]
              rmax = height[right]
              h = min(lmax, rmax)
              width = right - left 
              res = max(res, width * h)
              if lmax < rmax:
                  left += 1 
              else:
                  right -= 1 
          return res 
  ```

  

  

  

  