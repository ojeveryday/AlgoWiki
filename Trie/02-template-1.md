# 用数组模拟 Trie 

## 思想与模板

Trie 的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符 $C$ ，就沿着当前节点的 $C$ 字符指针，走到该指针指向的节点。下面我们来详细讨论 Trie 的基本操作过程：

1. 初始化：一棵空 Trie 仅包含一个根节点，该节点的字符指针均指向空。
2. 插入：当插入一个字符串 $S$ 时，我们令一个指针 $P$ 起初指向根节点，然后依次扫描 $S$ 中的每个字符 $C$ ：
   1. 若 $P$ 的 $C$ 字符指针指向一个已经存在的节点 $Q$ ，则令 $P=Q$ ；
   2. 若 $P$ 的 $C$ 字符指针指向空，则新建一个节点 $Q$ ，令 $P$ 的 $C$ 字符指针指向 $Q$，然后令 $P=Q$ ；
   3. 当 $S$ 中的字符扫描完毕时，在当前 $P$ 节点上标记它是一个字符串的末尾；
3. 检索：当需要检索一个字符串 $S$ 在 Trie 中是否存在时，我们令一个指针 $P$ 起初指向根节点，然后依次扫描 $S$ 中的每个字符 $C$ 。
   1. 若 $P$ 的 $C$ 字符指针指向空，则说明 $S$ 没有被插入过 Trie ，结束检索；
   2. 若 $P$ 的 $C$ 字符指针指向一个已经存在的节点 $Q$ ，则令 $P=Q$ ；
   3. 当 $S$ 中的字符串扫描完毕时，若当前节点 $P$ 被标记为一个字符串的末尾，则说明 $S$ 在 Trie 中存在，否则说明 $S$ 没有被插入过 Trie ；
   
![](https://ae01.alicdn.com/kf/H028b6926ac04486482df0d116e570122e.jpg)

在上图所示的例子中，需要插入和检索的字符串都由小写字母构成，所以 Trie 的每个节点具有 26 个字符指针，分别为 $a$ 到 $z$ 。上图展示了在一棵空树中依次插入``code``、``cool``、``coder``后的 Trie 形态，绿色标记了单词的末尾节点。可以看出在 Trie 中，字符数据都体现在树的边（指针）上，树的节点仅保存一些额外信息，例如单词结尾标记等，其空间复杂度是 $O(NC)$ ，其中 $N$ 是节点个数，$C$ 是字符集的大小。

如果按上文所说，我们可以在每个节点设一个布尔类型的值代表其是否为结尾，但是这种操作无法记录以此节点为末尾的字符串的数量，所以我们可以在每个节点用一个整型的值来代替其布尔类型的值，记录以此节点为末尾的字符串的数量。

<!-- tabs:start -->

#### **C++**

```C++
// son[][]存储树中每个节点的子节点
int son[N][26];
// cnt[]存储以每个节点结尾的单词数量
int cnt[N];
// idx为节点的编号
int idx;

// 0号点既是根节点，又是空节点

// 插入一个字符串
void insert(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}

// 查询字符串出现的次数
int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

<!-- tabs:end -->

## 练习题

「力扣」第 208 题：[实现Trie(前缀树)](https://leetcode-cn.com/problems/implement-Trie-prefix-tree/)。

此题为实现一个 Trie 树，通过此题可以检验大家的理解程度，也可以待掌握链表模拟 Trie 后写。