## 类型3：使用对撞指针的滑动窗口

「对撞指针」是双指针的一种变形，一个指针指向数组头，一个指向数组尾，两指针往相反的方向移动。而指针间可以被认为是一个窗口，这类滑动窗口也常常带有一点贪心算法的思想，例题如下：

「LeetCode」 第 11 题：[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 示例：
>
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49

假设给定的数组为 `height` ，则示例中的输出则可解释为 `49 = min(height[1], height[8]) * (8-1)` 

#### 思路

根据「木桶原理」，我们知道决定一个容器能盛多少水的因素有两个，一个是容器本身有多大，二是最短的那块木板有多长。而在这道题，数组中的元素值代表木板长度，两元素间的间距代表容器本身的大小，即窗口的大小。

可以发现，我们虽然不知道木板最长是多少，但窗口可以有多大是知道的——即数组长度 - 1那么大。因此我们不妨在一开始就把窗口设为最大，每次判断当前木板的长度和窗口大小能盛多少水，再逐渐将窗口缩小。至此，代码也就呼之欲出了。

python代码：

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        lp = 0  # 左指针，指向左侧的木板
        rp = len(height) - 1  # 右指针，指向右侧的木板
        res = 0  # 能容纳的最大水量
        
        while lp < rp:
            # 每次计算当前窗口和木板长度能容纳的水量，并更新能容纳的最大水量
            temp = min(height[lp], height[rp]) * (rp-lp)  
            res = max(res, temp)
            # 不断更换长度相对短的那个木板
            if height[lp] < height[rp]:
                lp += 1   
            else:
                rp -= 1
        
        return res
```